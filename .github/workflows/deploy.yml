name: Build & Deploy

on:
  push:
    branches:
      - main
    paths:
      - "src/**"
      - "package*.json"
      - "next.config.*"
  workflow_dispatch:

concurrency:
  group: deploy-production
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      BLOG_DOMAIN: ${{ secrets.BLOG_DOMAIN }}
      VM_HOST: ${{ secrets.VM_HOST }}
      VM_USER: ${{ secrets.VM_USER }}
      VM_SSH_KEY: ${{ secrets.VM_SSH_KEY }}
      ADMIN_USERNAME: ${{ secrets.ADMIN_USERNAME }}
      ADMIN_PASSWORD_HASH: ${{ secrets.ADMIN_PASSWORD_HASH }}
      ADMIN_SESSION_SECRET: ${{ secrets.ADMIN_SESSION_SECRET }}
      ADMIN_TOTP_SECRET_ENCRYPTION_KEY: ${{ secrets.ADMIN_TOTP_SECRET_ENCRYPTION_KEY }}
      ADMIN_CSRF_SECRET: ${{ secrets.ADMIN_CSRF_SECRET }}
      ADMIN_TOTP_SECRET: ${{ secrets.ADMIN_TOTP_SECRET }}
      ADMIN_TOTP_ISSUER: ${{ secrets.ADMIN_TOTP_ISSUER }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required secrets
        shell: bash
        run: |
          set -euo pipefail
          for name in BLOG_DOMAIN VM_HOST VM_USER VM_SSH_KEY ADMIN_USERNAME ADMIN_PASSWORD_HASH ADMIN_SESSION_SECRET ADMIN_TOTP_SECRET_ENCRYPTION_KEY ADMIN_CSRF_SECRET ADMIN_TOTP_SECRET; do
            if [ -z "${!name:-}" ]; then
              echo "::error::Missing required secret: ${name}"
              exit 1
            fi
          done

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build

      - name: Create release metadata
        id: release
        shell: bash
        run: |
          set -euo pipefail
          RELEASE_ID="$(date -u +%Y%m%d%H%M%S)"
          RELEASE_PATH="/opt/blog-v${RELEASE_ID}"
          ARCHIVE_NAME="blog-standalone-${RELEASE_ID}.tar.gz"

          echo "release_id=${RELEASE_ID}" >> "$GITHUB_OUTPUT"
          echo "release_path=${RELEASE_PATH}" >> "$GITHUB_OUTPUT"
          echo "archive_name=${ARCHIVE_NAME}" >> "$GITHUB_OUTPUT"

      - name: Package standalone artifact
        shell: bash
        run: |
          set -euo pipefail
          tar -czf "${{ steps.release.outputs.archive_name }}" \
            .next/standalone/ \
            .next/static/ \
            public/

      - name: Configure SSH
        shell: bash
        run: |
          set -euo pipefail
          install -m 700 -d ~/.ssh
          printf '%s\n' "${VM_SSH_KEY}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H "${VM_HOST}" >> ~/.ssh/known_hosts

      - name: Upload artifact to VM
        shell: bash
        run: |
          set -euo pipefail
          scp "${{ steps.release.outputs.archive_name }}" \
            "${VM_USER}@${VM_HOST}:/tmp/${{ steps.release.outputs.archive_name }}"

      - name: Build admin environment file
        shell: bash
        run: |
          set -euo pipefail
          ADMIN_ENV_FILE="/tmp/blog-admin.env"
          : > "${ADMIN_ENV_FILE}"

          {
            printf 'ADMIN_USERNAME=%s\n' "${ADMIN_USERNAME}"
            printf 'ADMIN_PASSWORD_HASH=%s\n' "${ADMIN_PASSWORD_HASH}"
            printf 'ADMIN_SESSION_SECRET=%s\n' "${ADMIN_SESSION_SECRET}"
            printf 'ADMIN_TOTP_SECRET_ENCRYPTION_KEY=%s\n' "${ADMIN_TOTP_SECRET_ENCRYPTION_KEY}"
            printf 'ADMIN_CSRF_SECRET=%s\n' "${ADMIN_CSRF_SECRET}"
            printf 'ADMIN_TOTP_SECRET=%s\n' "${ADMIN_TOTP_SECRET}"
            if [ -n "${ADMIN_TOTP_ISSUER:-}" ]; then
              printf 'ADMIN_TOTP_ISSUER=%s\n' "${ADMIN_TOTP_ISSUER}"
            fi
          } > "${ADMIN_ENV_FILE}"
          chmod 600 "${ADMIN_ENV_FILE}"

      - name: Upload admin environment file to VM
        shell: bash
        run: |
          set -euo pipefail
          scp /tmp/blog-admin.env "${VM_USER}@${VM_HOST}:/tmp/blog-admin.env"

      - name: Deploy release on VM
        shell: bash
        run: |
          set -euo pipefail

          ssh "${VM_USER}@${VM_HOST}" \
            "RELEASE_PATH='${{ steps.release.outputs.release_path }}' ARCHIVE_NAME='${{ steps.release.outputs.archive_name }}' bash -s" <<'REMOTE'
          set -euo pipefail

          RELEASE_PATH="${RELEASE_PATH}"
          ARCHIVE_PATH="/tmp/${ARCHIVE_NAME}"
          PREVIOUS_RELEASE=""
          PERSIST_ROOT="/var/lib/blog"
          PERSIST_DATA_DIR="${PERSIST_ROOT}/data"
          PERSIST_UPLOADS_DIR="${PERSIST_ROOT}/uploads"
          PERSIST_DB_PATH="${PERSIST_DATA_DIR}/blog.db"
          PREVIOUS_DB_PATH=""
          PREVIOUS_UPLOADS_PATH=""

          if [ -L /opt/blog ]; then
            PREVIOUS_RELEASE="$(readlink -f /opt/blog || true)"
          fi

          if [ -n "${PREVIOUS_RELEASE}" ]; then
            PREVIOUS_DB_PATH="${PREVIOUS_RELEASE}/data/blog.db"
            PREVIOUS_UPLOADS_PATH="${PREVIOUS_RELEASE}/uploads"
          fi

          if [ -d /opt/blog ] && [ ! -L /opt/blog ]; then
            if [ -z "$(ls -A /opt/blog)" ]; then
              sudo rmdir /opt/blog
            else
              echo "/opt/blog exists as a real directory. Convert it to symlink strategy before deploy."
              exit 1
            fi
          fi

          sudo mkdir -p "${RELEASE_PATH}"
          sudo tar -xzf "${ARCHIVE_PATH}" -C "${RELEASE_PATH}"

          # Keep /opt/blog/server.js compatible with the planned systemd layout.
          sudo cp -a "${RELEASE_PATH}/.next/standalone/." "${RELEASE_PATH}/"
          sudo install -d -m 755 -o blog -g blog "${PERSIST_DATA_DIR}" "${PERSIST_UPLOADS_DIR}"

          # First migration only: move DB from the previous release to persistent storage.
          if [ ! -f "${PERSIST_DB_PATH}" ] && [ -n "${PREVIOUS_DB_PATH}" ] && [ -f "${PREVIOUS_DB_PATH}" ]; then
            if ! command -v sqlite3 > /dev/null 2>&1; then
              echo "sqlite3 is required for WAL-safe .backup migration." >&2
              exit 1
            fi
            sudo sqlite3 "${PREVIOUS_DB_PATH}" ".backup ${PERSIST_DB_PATH}"
            sudo chown blog:blog "${PERSIST_DB_PATH}"
          fi

          # First migration only: move uploads when the persistent directory is still empty.
          if [ -n "${PREVIOUS_UPLOADS_PATH}" ] && [ -d "${PREVIOUS_UPLOADS_PATH}" ]; then
            PREVIOUS_UPLOADS_REALPATH="$(readlink -f "${PREVIOUS_UPLOADS_PATH}" || true)"
            PERSIST_UPLOADS_REALPATH="$(readlink -f "${PERSIST_UPLOADS_DIR}" || true)"
            if [ "${PREVIOUS_UPLOADS_REALPATH}" != "${PERSIST_UPLOADS_REALPATH}" ] && [ -z "$(sudo find "${PERSIST_UPLOADS_DIR}" -mindepth 1 -print -quit)" ]; then
              sudo cp -a "${PREVIOUS_UPLOADS_PATH}/." "${PERSIST_UPLOADS_DIR}/"
              sudo chown -R blog:blog "${PERSIST_UPLOADS_DIR}"
            fi
          fi

          sudo rm -rf "${RELEASE_PATH}/data" "${RELEASE_PATH}/uploads"
          sudo ln -sfn "${PERSIST_DATA_DIR}" "${RELEASE_PATH}/data"
          sudo ln -sfn "${PERSIST_UPLOADS_DIR}" "${RELEASE_PATH}/uploads"
          sudo chown -R blog:blog "${PERSIST_ROOT}"
          sudo chown -R blog:blog "${RELEASE_PATH}"

          sudo install -d -m 755 /etc/blog
          sudo install -m 600 -o root -g root /tmp/blog-admin.env /etc/blog/admin.env
          sudo install -d -m 755 /etc/systemd/system/blog.service.d
          sudo tee /etc/systemd/system/blog.service.d/10-admin-env.conf > /dev/null <<'OVERRIDE'
          [Service]
          EnvironmentFile=-/etc/blog/admin.env
          OVERRIDE
          sudo systemctl daemon-reload

          sudo ln -sfn "${RELEASE_PATH}" /opt/blog
          sudo systemctl restart blog

          if ! sudo systemctl is-active --quiet blog; then
            if [ -n "${PREVIOUS_RELEASE}" ]; then
              sudo ln -sfn "${PREVIOUS_RELEASE}" /opt/blog
              sudo systemctl restart blog || true
            fi
            exit 1
          fi

          echo "PREVIOUS_RELEASE=${PREVIOUS_RELEASE}" > /tmp/blog-deploy-state
          REMOTE

      - name: Health check and rollback on failure
        shell: bash
        run: |
          set -euo pipefail

          DOMAIN_HOST="${BLOG_DOMAIN#http://}"
          DOMAIN_HOST="${DOMAIN_HOST#https://}"
          DOMAIN_HOST="${DOMAIN_HOST%%/*}"
          HEALTHCHECK_URL="https://${DOMAIN_HOST}/api/health"

          if [ -z "${DOMAIN_HOST}" ]; then
            echo "BLOG_DOMAIN is empty or invalid: ${BLOG_DOMAIN}" >&2
            exit 1
          fi

          echo "BLOG_DOMAIN(raw): ${BLOG_DOMAIN}"
          echo "BLOG_DOMAIN(normalized host): ${DOMAIN_HOST}"
          echo "Healthcheck URL: ${HEALTHCHECK_URL}"

          if ! getent hosts "${DOMAIN_HOST}" > /dev/null; then
            echo "DNS lookup failed for ${DOMAIN_HOST}" >&2
          fi

          HEALTHCHECK_PASSED=false
          for attempt in {1..8}; do
            if curl -fsS --connect-timeout 10 --max-time 20 "${HEALTHCHECK_URL}" > /dev/null; then
              echo "Health check succeeded on attempt ${attempt}/8."
              HEALTHCHECK_PASSED=true
              break
            fi

            echo "Health check attempt ${attempt}/8 failed." >&2
            if [ "${attempt}" -lt 8 ]; then
              sleep 3
            fi
          done

          if [ "${HEALTHCHECK_PASSED}" != "true" ]; then
            echo "Health check failed for ${HEALTHCHECK_URL}" >&2
            echo "Diagnostic: getent hosts ${DOMAIN_HOST}" >&2
            getent hosts "${DOMAIN_HOST}" || true
            echo "Diagnostic: curl -v ${HEALTHCHECK_URL}" >&2
            curl -v --connect-timeout 10 --max-time 20 "${HEALTHCHECK_URL}" || true

            ssh "${VM_USER}@${VM_HOST}" "bash -s" <<'REMOTE'
              set -euo pipefail

              echo "Diagnostic: recent blog logs before rollback"
              sudo journalctl -u blog -n 80 --no-pager || true

              PREVIOUS_RELEASE=""
              if [ -f /tmp/blog-deploy-state ]; then
                . /tmp/blog-deploy-state
              fi

              if [ -n "${PREVIOUS_RELEASE}" ]; then
                sudo ln -sfn "${PREVIOUS_RELEASE}" /opt/blog
                sudo systemctl restart blog
                sudo systemctl is-active --quiet blog
              else
                echo "No previous release available for rollback."
                exit 1
              fi
          REMOTE

            exit 1
          fi

      - name: Append runbook summary row
        if: success()
        shell: bash
        run: |
          set -euo pipefail
          UTC_NOW="$(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          KST_NOW="$(TZ=Asia/Seoul date '+%Y-%m-%d %H:%M:%S KST')"
          echo "${{ github.run_id }} | ${UTC_NOW} / ${KST_NOW} | ${{ steps.release.outputs.release_path }} | success" >> "$GITHUB_STEP_SUMMARY"

      - name: Cleanup uploaded archive
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          rm -f /tmp/blog-admin.env
          ssh "${VM_USER}@${VM_HOST}" "rm -f /tmp/${{ steps.release.outputs.archive_name }} /tmp/blog-deploy-state /tmp/blog-admin.env"
